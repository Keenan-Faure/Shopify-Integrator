// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: products.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createProduct = `-- name: CreateProduct :execresult
INSERT INTO products(
    id,
    active,
    title,
    body_html,
    category,
    product_type,
    created_at,
    updated_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateProductParams struct {
	ID          string         `json:"id"`
	Active      string         `json:"active"`
	Title       sql.NullString `json:"title"`
	BodyHtml    sql.NullString `json:"body_html"`
	Category    string         `json:"category"`
	ProductType sql.NullString `json:"product_type"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createProduct,
		arg.ID,
		arg.Active,
		arg.Title,
		arg.BodyHtml,
		arg.Category,
		arg.ProductType,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
}

const getProductByActiveStatus = `-- name: GetProductByActiveStatus :many
SELECT
    active,
    title,
    body_html,
    category,
    product_type,
    updated_at
FROM products
WHERE active = ?
`

type GetProductByActiveStatusRow struct {
	Active      string         `json:"active"`
	Title       sql.NullString `json:"title"`
	BodyHtml    sql.NullString `json:"body_html"`
	Category    string         `json:"category"`
	ProductType sql.NullString `json:"product_type"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

func (q *Queries) GetProductByActiveStatus(ctx context.Context, active string) ([]GetProductByActiveStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductByActiveStatus, active)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductByActiveStatusRow
	for rows.Next() {
		var i GetProductByActiveStatusRow
		if err := rows.Scan(
			&i.Active,
			&i.Title,
			&i.BodyHtml,
			&i.Category,
			&i.ProductType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT
    active,
    title,
    body_html,
    category,
    product_type,
    updated_at
FROM products
WHERE id = ?
`

type GetProductByIDRow struct {
	Active      string         `json:"active"`
	Title       sql.NullString `json:"title"`
	BodyHtml    sql.NullString `json:"body_html"`
	Category    string         `json:"category"`
	ProductType sql.NullString `json:"product_type"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

func (q *Queries) GetProductByID(ctx context.Context, id string) (GetProductByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.Active,
		&i.Title,
		&i.BodyHtml,
		&i.Category,
		&i.ProductType,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :execresult
UPDATE products
SET
    active = ?,
    title = ?,
    body_html = ?,
    category = ?,
    product_type = ?,
    updated_at = ?
WHERE id = ?
`

type UpdateProductParams struct {
	Active      string         `json:"active"`
	Title       sql.NullString `json:"title"`
	BodyHtml    sql.NullString `json:"body_html"`
	Category    string         `json:"category"`
	ProductType sql.NullString `json:"product_type"`
	UpdatedAt   time.Time      `json:"updated_at"`
	ID          string         `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateProduct,
		arg.Active,
		arg.Title,
		arg.BodyHtml,
		arg.Category,
		arg.ProductType,
		arg.UpdatedAt,
		arg.ID,
	)
}
