// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.0
// source: products.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createProduct = `-- name: CreateProduct :execresult
INSERT INTO products(
    active,
    title,
    body_html,
    category,
    vendor,
    product_type,
    created_at,
    updated_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateProductParams struct {
	Active      string         `json:"active"`
	Title       sql.NullString `json:"title"`
	BodyHtml    sql.NullString `json:"body_html"`
	Category    sql.NullString `json:"category"`
	Vendor      sql.NullString `json:"vendor"`
	ProductType sql.NullString `json:"product_type"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createProduct,
		arg.Active,
		arg.Title,
		arg.BodyHtml,
		arg.Category,
		arg.Vendor,
		arg.ProductType,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
}

const getProductByID = `-- name: GetProductByID :one
SELECT
    active,
    title,
    body_html,
    category,
    vendor,
    product_type,
    updated_at
FROM products
WHERE id = ?
`

type GetProductByIDRow struct {
	Active      string         `json:"active"`
	Title       sql.NullString `json:"title"`
	BodyHtml    sql.NullString `json:"body_html"`
	Category    sql.NullString `json:"category"`
	Vendor      sql.NullString `json:"vendor"`
	ProductType sql.NullString `json:"product_type"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

func (q *Queries) GetProductByID(ctx context.Context, id []byte) (GetProductByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.Active,
		&i.Title,
		&i.BodyHtml,
		&i.Category,
		&i.Vendor,
		&i.ProductType,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductsByCategory = `-- name: GetProductsByCategory :many
SELECT
    active,
    title,
    body_html,
    category,
    vendor,
    product_type,
    updated_at
FROM products
WHERE category REGEXP ?
LIMIT ? OFFSET ?
`

type GetProductsByCategoryParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProductsByCategoryRow struct {
	Active      string         `json:"active"`
	Title       sql.NullString `json:"title"`
	BodyHtml    sql.NullString `json:"body_html"`
	Category    sql.NullString `json:"category"`
	Vendor      sql.NullString `json:"vendor"`
	ProductType sql.NullString `json:"product_type"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

func (q *Queries) GetProductsByCategory(ctx context.Context, arg GetProductsByCategoryParams) ([]GetProductsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByCategory, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByCategoryRow
	for rows.Next() {
		var i GetProductsByCategoryRow
		if err := rows.Scan(
			&i.Active,
			&i.Title,
			&i.BodyHtml,
			&i.Category,
			&i.Vendor,
			&i.ProductType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByFilter = `-- name: GetProductsByFilter :many
SELECT
    active,
    title,
    body_html,
    category,
    vendor,
    product_type,
    updated_at
FROM products
WHERE category IN (?)
AND product_type IN (?)
AND vendor IN (?)
LIMIT ? OFFSET ?
`

type GetProductsByFilterParams struct {
	Category    sql.NullString `json:"category"`
	ProductType sql.NullString `json:"product_type"`
	Vendor      sql.NullString `json:"vendor"`
	Limit       int32          `json:"limit"`
	Offset      int32          `json:"offset"`
}

type GetProductsByFilterRow struct {
	Active      string         `json:"active"`
	Title       sql.NullString `json:"title"`
	BodyHtml    sql.NullString `json:"body_html"`
	Category    sql.NullString `json:"category"`
	Vendor      sql.NullString `json:"vendor"`
	ProductType sql.NullString `json:"product_type"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

func (q *Queries) GetProductsByFilter(ctx context.Context, arg GetProductsByFilterParams) ([]GetProductsByFilterRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByFilter,
		arg.Category,
		arg.ProductType,
		arg.Vendor,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByFilterRow
	for rows.Next() {
		var i GetProductsByFilterRow
		if err := rows.Scan(
			&i.Active,
			&i.Title,
			&i.BodyHtml,
			&i.Category,
			&i.Vendor,
			&i.ProductType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByType = `-- name: GetProductsByType :many
SELECT
    active,
    title,
    body_html,
    category,
    vendor,
    product_type,
    updated_at
FROM products
WHERE product_type REGEXP ?
LIMIT ? OFFSET ?
`

type GetProductsByTypeParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProductsByTypeRow struct {
	Active      string         `json:"active"`
	Title       sql.NullString `json:"title"`
	BodyHtml    sql.NullString `json:"body_html"`
	Category    sql.NullString `json:"category"`
	Vendor      sql.NullString `json:"vendor"`
	ProductType sql.NullString `json:"product_type"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

func (q *Queries) GetProductsByType(ctx context.Context, arg GetProductsByTypeParams) ([]GetProductsByTypeRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByType, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByTypeRow
	for rows.Next() {
		var i GetProductsByTypeRow
		if err := rows.Scan(
			&i.Active,
			&i.Title,
			&i.BodyHtml,
			&i.Category,
			&i.Vendor,
			&i.ProductType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByVendor = `-- name: GetProductsByVendor :many
SELECT
    active,
    title,
    body_html,
    category,
    vendor,
    product_type,
    updated_at
FROM products
WHERE vendor REGEXP ?
LIMIT ? OFFSET ?
`

type GetProductsByVendorParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetProductsByVendorRow struct {
	Active      string         `json:"active"`
	Title       sql.NullString `json:"title"`
	BodyHtml    sql.NullString `json:"body_html"`
	Category    sql.NullString `json:"category"`
	Vendor      sql.NullString `json:"vendor"`
	ProductType sql.NullString `json:"product_type"`
	UpdatedAt   time.Time      `json:"updated_at"`
}

func (q *Queries) GetProductsByVendor(ctx context.Context, arg GetProductsByVendorParams) ([]GetProductsByVendorRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductsByVendor, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductsByVendorRow
	for rows.Next() {
		var i GetProductsByVendorRow
		if err := rows.Scan(
			&i.Active,
			&i.Title,
			&i.BodyHtml,
			&i.Category,
			&i.Vendor,
			&i.ProductType,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :execresult
UPDATE products
SET
    active = ?,
    title = ?,
    body_html = ?,
    category = ?,
    vendor = ?,
    product_type = ?,
    updated_at = ?
WHERE id = ?
`

type UpdateProductParams struct {
	Active      string         `json:"active"`
	Title       sql.NullString `json:"title"`
	BodyHtml    sql.NullString `json:"body_html"`
	Category    sql.NullString `json:"category"`
	Vendor      sql.NullString `json:"vendor"`
	ProductType sql.NullString `json:"product_type"`
	UpdatedAt   time.Time      `json:"updated_at"`
	ID          []byte         `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateProduct,
		arg.Active,
		arg.Title,
		arg.BodyHtml,
		arg.Category,
		arg.Vendor,
		arg.ProductType,
		arg.UpdatedAt,
		arg.ID,
	)
}
